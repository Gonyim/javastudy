# 3.5장 : 메소드, 예외 처리

## 메소드에서 배열 리턴
- 메소드에서 어떤 배열이든지 리턴하면, 배열 공간 전체가 아니라 배열에 대한 레퍼런스만 리턴한다.
```java
1. int[] 배열을 리턴하는 makeArray() 메소드 코드

int[] makeArray() {             // int[] : 리턴 타입, makeArray : 메소드 이름
    int temp[] = new int[4];
    return temp;                // temp : 배열 리턴
}


2. makeArray() 메소드로부터 배열을 리턴받는 코드

int [] intArray;        // makeArray()의 리턴 타입과 동일한 타입 선언
intArray = makeArray(); // makeArray() 메소드가 리턴하는 배열 받음
```

## main 메소드
- main 메소드는 자바 응용프로그램의 실행이 시작되는 특별한 메소드로서 원형은 다음과 같다.

```java
public static void main(String[] args) {
}
```
|단어|의미|
|---|---|
|public|다른 클래스에서 메소드 접근 허용|
|static|객체 생성 전부터 호출 가능|
|void|리턴 값 없음|
|String[]|문자열 배열|
|args|매개변수|
***

### main() 메소드의 특징
1. main() 메소드는 public속성이다.
   - public 속성은 메소드가 다른 클래스에서 호출 가능함을 나타낸다.(자바 응요 프로그램이 실행될 때 JVM에 호출되어야 하므로)
2. main() 메소드는 static속성이다.
   - main() 메소드는 자신을 포함하는 클래스의 객체가 생성되기 전에, 처음부터 JVM에 의해 호출되므로 static 속성으로 선언되어야 한다.
   - static 속성은 클래스 로딩 시에 멤버가 생성되며, 객체가 생기기 전에 이미 생성되고, 객체가 생기기 전에 사용 가능하다.
3. main() 메소드의 리턴 타입은 void이다.
   - 아무 값도 리턴하지 않기 때문에 void 타입이다. main() 메소드를 끝내기 위해 리턴하려면 단순히 return; 문을 사용하면 된다.
4. main() 메소드에는 문자열 배열(String [])이 매개변수로 전달된다.
   - 자바는 명령행에 입력된 인자들을 문자열 배열로 만들어 main() 메소드에 전달한다.
***

## 자바의 예외 처리
- 자바에서 오동작이나 결과에 악영향을 미칠 수 있는 실행 중 발생한 오류를 예외(Exception)라고 한다.

1. 정수를 0으로 나누는 경우
2. 배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
3. 존재하지 않는 파일을 읽으려고 하는 경우
4. 정수 입력을 기다리는 코드가 실행되고 있을 때, 사용자가 문자를 입력한 경우
***

- 예외(Exception)와 실행시간 오류(run-time error)의 차이점
  - **실행시간 오류**는 조건문이 잘못 작성된 반복문이 무한루프를 실행하거나 recursion(반복)을 제어하는 코드를 잘못 작성하여 스택이 계속 쌓여(스택 오버플로우) JVM의 메모리가 부족할 때까지 실행되는 등 언제 어디서 발생할지 **예측할 수 없고**, 발생하였을 때 시스템이나 사용자에게 해를 주거나 강제로 프로그램을 종료시키지 않으면 **멈출 수 없는** 경우이다.
  - 예외란 사용자 프로그램에서 try-catch 블록을 이용하여 **제어할(handling) 수 있는** 실행시간 오류이다. 파일을 여는 코드나 나누기 하는 코드 등을 작성할 때 파일을 열지 못할 수 있고, 0으로 나누기가 이루어질 수 있음을 알고, 또 이런 상황에 발생하였을 때는 try-catch 블록을 이용하여 **문제를 바로 잡아(recoverable) 계속 실행**되게 하거나, 시스템이나 사용자에게 해를 끼치지 않으면서 정상적인 방법이나 프로그램을 종료시킬 수 있도록 **제어 가능**한 경우이다.
***

### 예외 처리, try-catch-finally 문
- 예외 처리란 개발자가 작성한 프로그램의 실행 중에 예외가 발생하면 이에 대응하는 것을 말한다. 자바는 예외 처리를 위해 try-catch-finally 문을 사용한다.

```java
try {
    예외가 발생할 가능성이 있는 실행문(try 블록)
}
catch (처리할 예외 타입 선언) {
    예외 처리문(catch 블록)
}
finally {
    예외 발생 여부와 상관없이 무조건 실행되는 문장(finally 블록)
}

// finally 문은 생략 가능하다.
```
- 예외가 발생할 가능성이 있는 실행문들을 try {} 블록으로 묶고, 예외 처리 코드는 catch {} 블록 내에 작성한다.
- catch() 문의 () 안에는 처리하고자 하는 예외의 타입을 선언한다. catch {} 블록은 예외마다 하나씩 작성되어야 한다.
- finally {} 블록은 생략해도 상관없으며 실제 많은 경우 생략한다. finally 블록은 예외가 발생하든 않든 마지막에 반드시 실행된다.
- 만일 발생한 예외 타입과 일치하는 catch 블록이 없으면 프로그램은 강제 종료된다.
- catch 블록 내에서 System.exit(0)을 호출하면 언제든지 프로그램을 종료할 수 있다.
***

### 자바의 예외 클래스
- 응용프로그램에서는 자바 플랫폼에서 제공하는 예외 클래스를 이용하여 예외 발생을 탐지할 수 있다.

|예외 타입(예외 클래스)|예외 발생 경우|패키지|
|---|---|---|
|ArithmeticException|정수를 0으로 나눌 때 발생|java.lang|
|NullPointerException|null 레퍼런스를 참조할 때 발생|java.lang|
|ClassCastException|변환할 수 없는 타입으로 객체를 변환할 때 발생|java.lang|
|OutOfMemoryError|메모리가 부족한 경우 발생|java.lang|
|ArrayIndexOutOfBoundsException|배열의 범위를 벗어난 접근 시 발생|java.lang|
|IllegalArgumentException|잘못된 인자 전달 시 발생|java.lang|
|IOException|입출력 동작 실패 또는 인터럽트 시 발생|java.io|
|NumberFormatException|문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환 시 발생|java.lang|
|InputMismatchException|Scanner 클래스의 nextInt()를 호출하여 정수로 입력받고자 하였지만, 사용자가 'a' 등과 같이 문자를 입력한 경우|java.util|
***

# 4장 : 클래스와 객체

## 객체 지향과 자바
- 우리 주변에 있는 모든 것이 객체이며, 각각의 고유한 특성과 행동을 가지며 다른 객체들과 상호작용한다.

## 객체 지향 언어의 특성
### 캡슐화(Encapsulation)
- 캡슐화란 객체를 캡슐로 싸서 내부를 보호하고 볼 수 없게 하는 것으로 객체의 가장 본질적인 특징이다.
- 자바에서 객체는 클래스(class)라는 캡슐을 사용하며, 필드(멤버 변수)와 메소드(멤버 함수)로 구성된다.

### 상속(Inheritance)
- 자바에서의 상속은 자식 클래스가 부모 클래스의 속성을 물려받고 기능을 추가하여 확장(Extends)하는 개념이다.
- 자바에서 부모 클래스를 슈퍼 클래스라고 부르면 자식 클래스를 서브 클래스라고 부른다.
- 상속은 슈퍼 클래스의 필드와 메소드를 물려받아 코드를 재사용함으로써, 코드 작성에 드는 시간과 비용을 줄인다.

<예시>
```java
class Animal {                  // 슈퍼 클래스
    String name;
    int age;
    void eat() {...}
}

class Human extends Animal {    // 서브 클래스
    String Hobby;
    String job;
    void work() {...}
}
```

### 다형성(Polymorphism)
- 다형성은 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것을 말한다.
- 슈퍼 클래스에 구현된 메소드를, 서브 클래스에서 동일한 이름으로 자신의 특징에 맞게 다시 구현하는 이른바 **메소드 오버라이딩**으로 불린다.
- 다형성의 또 다른 사례는 클래스 내에서 이름이 같지만 서로 다르게 동작하는 메소드를 여러 개 만드는 **메소드 오버로딩**이 있다.

## 객체지향의 목적
- 객체 지향 언어는 절차 지향 언어의 단점을 보완하고 목적을 달성하기 위해 탄생하였다.
1. 소프트웨어의 생산성 향상
2. 실세계에 대한 쉬운 모델링

## 절차 지향 프로그래밍과 객체 지향 프로그래밍
- 절차 지향 프로그래밍은 실행하고자 하는 절차를 정하고 흐름도를 설계하고 흐름도상의 동작들을 함수로 작성하며, 흐름도에 따라 일련의 동작들이 순서대로 실행되도록 작성한다.
- 객체 지향 프로그래밍은 프로그램을 실제 세상에 가깝게 모델링하여 물체를 객체로 표현하고 객체들의 관계, 상호 작용을 설계한 후 각 객체를 클래스로 작성한 것이다.