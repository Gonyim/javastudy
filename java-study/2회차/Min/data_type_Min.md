# 자료형

데이터를 저장하려면 메모리에 값을 저장할 공간을 생성하고 이름을 부여해야 합니다.
이때 메모리 공간에 부여하는 이름을 `변수`라고 합니다.
또한, 데이터를 저장하기 위해 생성하는 메모리 공간은 목적에 따라 크기와 타입이 다르며, 이를 `자료형(data type)`이라고 합니다.  그러므로 메모리 공간의 자료형에 따라 저장할 수 있는 값의 종류와 특징이 결정됩니다.

## 변수와 자료형(자료형 선언하기)

자바와 같은 `컴파일(Compile)`언어는 변수를 사용하기 전에 반드시 자료형을 선언해줘야 합니다.

```Java
int a;      // a는 int형 변수
String b;   // b는 String형 변수
```

이때 2가지 주의할 점이 있으며, 첫 째는 자료형은 반드시 사용하기 전에 선언되어 있어야 하며, 둘 째는 한번 선언된 자료형은 바꿀 수 없습니다.

> 변수를 선언하면서 초기값을 줄 수도 있습니다.
```Java
int a = 10;
```

## 이름 짓기

변수와 상수의 이름을 지을 때는 필수 사항과 권장 사항을 준수해야 합니다.
필수 사항은 지키지 않으면 `문법 오류(systax error)`가 발생해 컴파일 자체가 안되며, 권장 사항은 개발자끼리의 암묵적인 약속으로 가독성의 영향을 끼칩니다.

### 이름 지을 때 지켜야 하는 필수 사항

자바 문법을 구성하는 가장 대표적인 요소는 변수, 상수, 메서드가 있습니다.
영문 대소 문자와 한글을 사용할 수 있으며, 특수 문자는 `언더스코어(underscore)`와 `달러($)`표기만 가능합니다.  또한, 아라비아 숫자를 사요할 수 있지만 첫 번째 글자로는 사용 할 수 없습니다.
그리고 다른 언어와 마찬가지로 예약어를 사용할 수 없습니다.

```Java
// 영문 대소 문자와 한글
int abc, ABC, aBc, 가나다;

// 특수 문자(underscore, $)
String $abc, _abc, ab_c, $abc_;

// 아라비아 숫자
double a3bc, abc3;
```

### 이름을 지을 때 지키면 좋은 권장 사항

변수명을 지을 때는 영문 소문자로 시작하여, 2개 이상의 단어를 결합할 때는 `카멜 케이스(camelCase)`를 사용합니다.

```Java
int maxValue;
```

> 메서드명도 변수명과 동일하게 `카멜 케이스(camel case)`를 사용합니다.

상수명을 지을 때는 대문자 `스네이크 케이스(snake case)`를 사용합니다.

```Java
final int MY_DATA;
```

> `final 변수` : 자바 언어에서 final은 오직 한 번만 할당할 수 있는 entity를 정의할 때 사용됩니다.  즉 한 번 값을 넣어두면 절대 바뀌지 않는 값입니다.

### 변수의 생존 기간

변수의 생존 기간은 메모리에 변수가 만들어진 이후 사라지기까지의 기간을 의미합니다.
개발자가 직접 변수를 생성하지만 메모리에서 변수를 삭제하는 작업은 `자바 가상 머신(Java Virtual Machine)`이 알아서 합니다.
변수를 삭제하는 주체가 개발자가 아닌 JVM이 하기 때문에, 이미 메모리에서 사라진 변수를 사용할 경우 문법 오류가 발생되어, 메모리에서 사라지는 시점을 이해하는 것은 매우 중요합니다.

```Java
{
    int a;      // 변수 a의 생성 시점
    {
        a = 4;
    }
}               // 변수 a의 소멸 시점
```

위 예시 코드에서 볼 수 있듯이, 변수의 생존 기간은 변수가 선언된 `스코프(Scope)`입니다.

## 자료형의 종류

자바의 자료형은 크게 `기본 자료형`과 `참조 자료형`으로 나눌 수 있습니다.

| 구분        | 저장값                   | 자료형                   |
|-------------|--------------------------|--------------------------|
| 기본 자료형 | 참, 거짓: ture, false    | boolean                  |
|             | 정수: …, -1, 0, 1, …     | byte, short, int, long   |
|             | 실수: …, -1.5, 1, 7.5, … | float, double            |
|             | 문자(정수): ‘A’, ‘b’, …  | char                     |
| 참조 자료형 | 객체: Object             | 배열, 클래스, 인터페이스 |


기본 자료형과 참조 자료형의 저장방식은 서로 다릅니다.
메모리는 목적에 따라 크게 3가지 영역으로 나뉘며, 첫 번째 영역은 클래스(class) 영역, 정적(static) 영역, 상수(final) 영역, 메서드(method) 영역으로 나눠지며, 두 번째 영역은 스택(stack) 영역, 세 번째 영역은 힙(heap) 영역으로, 객체들이 저장되는 공간입니다.

| 클래스(class) 영역 정적(static) 영역 상수(final) 영역 메서드(method) 영역 	| 스택(stack) 영역 	| 힙(heap) 영역 	|
|---------------------------------------------------------------------------	|------------------	|---------------	|


### 기본 자료형과 참조 자료형의 차이점

- 자료형의 이름 규칙
기본 자료형과 참조 자료형의 첫 번째 차이점은 이름 규칙이 다릅니다.
자바에서 제공하는 기본 자료형 8개의 이름은 모두 소문자(int, long, float, double, ...)로 시작하는 반면, 참조 자료형의 이름은 모두 대문자(String, System, ...)로 시작합니다.

> 권장사항이기는 하나 개발자 사이의 무언의 약속이므로 웬만하면 꼭 지켜야 하는 것을 권장합니다.

- 실제 데이터값의 저장 위치
두 번째 차이점은 값의 저장 위치가 다릅니다.
기본 자료형은 스택(stack) 영역 메모리에 생성된 공간에 실제 변숫값을 저장하는 반면, 참조 자료형은 실제 데이터 값은 힙(heap) 영역 메모리에 저장하고, 스택(stack) 영역 메모리의 변수 공간에는 실제 변숫값이 저장된 힙(heap) 영역 메모리의 위치값을 저장합니다.


### 기본 자료형의 메모리 크기와 저장할 수 있는 값의 범위

| 자료형     	|         	| 자료의 크기 	| 값의 범위                 	|
|------------	|---------	|-------------	|---------------------------	|
| 부울대수   	| boolean 	| 1byte       	| true, false               	|
| 정수       	| byte    	| 1byte       	| -27 ~ 27-1                	|
|            	| short   	| 2byte       	| -215~215-1                	|
|            	| int     	| 4byte       	| -231~231-1                	|
|            	| long    	| 8byte       	| -263~263-1                	|
| 실수       	| float   	| 4byte       	| ±(1.40*10-45~3.40*1038)   	|
|            	| double  	| 8byte       	| ±(4.94*10-324~1.79*10308) 	|
| 문자(정수) 	| char    	| 2byte       	| 유니코드 문자(0~216-1)    	|



| 구분          	| 부호 비트 	| 가수 비트 	| 지수 비트 	|
|---------------	|-----------	|-----------	|-----------	|
| float(32bit)  	| 1         	| 23        	| 8         	|
| double(64bit) 	| 1         	| 52        	| 11        	|


> 메모리의 효율성 때문에 똑같은 정수를 사용하더라도 4가지의 자료형으로 저장합니다.

> 여기서 주의해야 할 사항은 자바에서는 코드에 직접 작성한 값을 `리터럴(literal)`이라고 하는데, 정수 리터럴의 기준은 크게 2가지로 byte와 short 자료형이 있습니다.  하지만 byte와 short에 저장할 범위를 넘어서게 되면 보통 int형으로 저장되며, long형으로 저장하고 싶다면 리터럴 뒤에 long을 나타내는 L(또는 l)을 붙여 넣을 수 있습니다.

> float 자료형의 정밀도는 소수점 7자리이며, double 자료형의 정밀도는 소수점 15자리입니다.

### 문자 자료형

문자를 저장하는 자료형인 char형은 문자를 작은따옴표(") 안에 표기해서 정의합니다.

```Java
char a = 'A'
```

만약 위처럼 저장하게 되면 메모리에 문자를 저장하는 것이 아닌 `유니코드(unicode)`에 정수값을 매겨 놓은 값으로 메모리에 저장합니다.

따라서 아래와 같이 반대로 저장할 수도 있습니다.

```Java
char a = 'A';           // 문자
char b = 65;            // 10진수
char c = 0b1000001;     // 2진수
char d = 00101;         // 8진수
char e = 0x0041;        // 16진수
char f = '\u0041';      // 유니코드
```

## 기본 자료형 간의 타입 변환

7가지 자료형 중 boolean을 제외한 자료형을 서로 변환할 수 있는 것을 `타입 변환(type casting)`이라고 합니다.

여기서 반드시 고려해야 할 점은 타입 변환을 수행할 때는 저장할 수 있는 값의 범위나 종류가 달라지므로 값이 변할 수 있다는 것입니다.

```Java
package type_casting;

public class TypeCasting_1 {
    public static void main(String[] args) {
        // 캐스팅 방법
        int value1 = (int)3.5;      // 3
        long value2 = (long)10;     // 10
        float value3 = (float)5.8   // 5.8
        double value4 = (double)16; // 16.0

        // 캐스팅 방법2
        long value5 = 10L;          // 10;
        long value6 = 10l;          // 10;
        float value7 = 5.8F;        // 5.8
        float value8 = 5.8f;        // 5.8
    }
}
```

### 자동 타입 변환과 수동 타입 변환

타입 변환은 컴파일러가 자동으로 수행하는 자동 타입 변환과 개발자가 직접 타입 변환을 하는 수동 타입 변환이 있습니다.
예를 들어 작은 자료형을 큰 자료형에 담으면 개발자가 타입 변환 코드를 넣어 주지 않더라도 컴파일러가 자동으로 타입 변환을 실행하며 이를 `업캐스팅(up-casting)`이라고 합니다.

반대로 큰 자료형을 작은 자료형에 대입하는 행위를 `다운캐스팅(down-casting)`이라고 합니다.
이는 데이터 손실이 발생될 수 있으므로 컴파일러가 자동으로 하지 않고 개발자가 수동으로 진행 변환을 해줘야 합니다.

```Java
package type_casting_2;

public class TypeCasting_2 {
    public static void main(String[] args) {
        // 자동 타입 변환
        float value1 = 3;       // int -> float(up-casting)
        long value2 = 5;        // int -> long(up-casting)
        double value3 = 7;      // int -> double(up-casting)
        byte value4 = 9;        // int -> byte
        short vbalue5 = 11;      // int -> short

        // 수동 타입 변환
        byte value6 = (byte)128;        // int -> byte(down-casting)
        int value7 = (int)3.5;          // double -> int(down-casting)
        float value8 = (float)7.5;      // double -> float(down-casting)
    }
}
```

> `value4`와 `value5`는 자동 변환으로 자료형을 변환했을 때 값에 오차가 없으므로 예외적으로 자동 변환이 수행됩니다.

> `value6`의 경우 값이 -128로 변환됩니다.  이유는 정수형 자료형을 작은 범위의 자료형으로 캐스팅할 때는 범위의 반대쪽 끝에서부터 다시 시작하는 `서큘러(circular)`구조를 보이기 때문입니다.

```Java
byte a = (byte)128;     // -128로 변환
byte b = (byte)129;     // -127로 변환
byte c = (byte)-129;    // 127로 변환
byte d = (byte)-130;    // 126으로 변환
```

### 기본 자료형 간의 연산

boolean을 제외한 기본 자료형은 서로 연산할 수 있습니다.
모든 연산은 같은 자료형끼리만 가능하며 연산 결과 역시 같은 자료형이 나오는 게 일반적입니다.
하지만 int보다 작은 자료형 간의 연산 결과는 int가 나옵니다.
이는 CPU에서 연산 최소 단위가 int이므로 int보다 작은 자료형도 int로 읽어 와서 연산을 수행하기 때문입니다.

| 연산            	| 결과   	|
|-----------------	|--------	|
| byte + byte     	| `int`    	|
| short + short   	| `int`    	|
| int + int       	| int    	|
| long + long     	| long   	|
| float + float   	| float  	|
| double + double 	| double 	|


다른 타입끼리 연산을 할 경우 컴파일러가 자동으로 업케스팅하여 연산합니다.

| 연산           	| 결과   	|
|----------------	|--------	|
| byte + short   	| `int`    	|
| byte + int     	| int    	|
| short + long   	| long   	|
| int + float    	| float  	|
| long + float   	| float  	|
| float + double 	| double 	|
