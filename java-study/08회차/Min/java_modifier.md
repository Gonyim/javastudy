# 자바 제어자1

## 접근 지정자
자바 제어자(java modifier)는 클래스, 필드, 메서드, 생성자 등에게 어떠한 특징을 부여하는 문법 요소입니다.
여기서 접근 지정자는 자바 제어자의 한 종류로 클래스, 멤버, 생성자 앞에 위치할 수 있으며, 사용 범위를 정의하는 역할을 합니다.

### 멤버 및 생성자의 접근 지정자
멤버(필드, 메서드, 이너 클래스) 및 생성자에는 public, protected, default(or package), private라는 4가지 종류의 접근 지정자를 사용할 수 있습니다.
만약 아무것도 작성하지 않으면 default 접근 지정자가 자동으로 설정됩니다.

```java
// 멤버 및 생성자에서 사용하는 4가지 접근 지정자
class Test {
    public int a;
    protected int b;
    int c;          // default 접근 지정자 자동 설정
    private int d;
    public void abc() {}
    protected void bcd() {}
    void cde() {}   // default 접근 지정자 자동 설정
    private void def() {}
}
```

4가지 접근 지정자 중에서 public의 사용 범위가 가장 넓으며, private가 가장 좁습니다. 따라서 접근 범위는 `public > protected > default > private`순입니다.

- `private`: 자신의 클래스 내부에서만 사용할 수 있는 접근 지정자입니다.
같은 멤버끼리만 사용할 수 있으며, 외부 클래스에서는 전혀 사용할 수 없습니다.

- `default`: `package 접근 지정자`라고 합니다.

- `protected`: 일단 default보다는 넓은 범위의 접근 지정자이므로 같은 패키지의 모든 클래스에서 사용 가능하며, 추가로 다른 패키지의 자식 클래스 안에서 사용할 수 있습니다.

- `public`: 동일 패키지의 모든 클래스와 다른 패키지의 모든 클래스. 즉, 어디에서나 사용할 수 있습니다.

| 접근 지정자 	| 사용 가능 범위                                                      	|
|-------------	|---------------------------------------------------------------------	|
| public      	| `동일 패키지`의 `모든 클래스` + `다른 패키지`의 `모든 클래스`에서 사용 가능 	|
| protected   	| `동일 패키지`의 `모든 클래스` + `다른 패키지`의 `자식 클래스`에서 사용 가능 	|
| default     	| `동일 패키지`의 `모든 클래스`에서 사용 가능                             	|
| private     	| `동일 클래스`에서 사용 가능                                           	|


```java
// 패키지 abc
package abc;
public class A {
    public int a;
    protected int b;
    int c;          // default 접근 지정자
    private int d;
    void () {
        // a, b, c, d 사용 가능
    }
}

package abc;
class B {
    // a, b, c 사용 가능
}


// 패키지 bcd
package bcd;
class C {
    // a 사용 가능 
}

package bcd;
class D extends A {
    // a, b 사용 가능
}
```

- protected 접근 지정자가 선언된 class A를 상속받은 D 클래스에서 사용 가능한 것을 확인할 수 있습니다.

### 클래스의 접근 지정자
클래스에서는 public, default 접근 지정자만 사용할 수 있습니다.
`클래스를 default로 정의하면 다른 패키지에서 임포트가 불가능`하여 사용할 수 없습니다.
즉, 다른 패키지에서 클래스를 사용하기 위해서는 해당 클래스를 임포트 할 수 있어야 하므로 public으로 선언해야 합니다.

> 임포트 대신 `패키지명.클래스명`을 바로 사용할 때도 당연히 public으로 선언돼 있어야 해당 클래스명을 인식할 수 있습니다.

### 클래스 접근 지정자와 생성자 접근 지정자의 연관성
클래스 접근 지정자와 생성자 접근 지정자는 매우 밀접한 관련이 있습니다.
클래스에 생성자가 없으면 컴파일러가 자동으로 생성자를 추가하고, 이때 `자동으로 추가되는 생성자의 접근 지정자는 클래스의 접근 지정자에 따라 결정됩니다.`
물론 개발자가 정의하여 다르게 지정할 수 있습니다.

클래스가 public이라는 것은 다른 패키지에서 임포트 할 수 있는 것이고, 생성자가 public이라는 것은 생성자를 호출해 객체를 생성할 수 있다는 것입니다.

- 클래스, 생성자 모두 public일 때 당연히 다른 패키지에서 임포트 및 객체를 생성할 수 있습니다.

- 하지만, 클래스가 default일 경우, 다른 패키지에서 임포트 자체를 하지 못하기 때문에 사용할 수 없습니다.

- 여기서 클래스가 public이고 생성자가 default일 경우에는 다른 패키지에서 임포트 할 수 있지만, 객체는 생성할 수 없습니다.


## static 제어자
static은 클래스의 멤버(필드, 메서드, 이너 클래스)에 사용하는 제어자입니다.
클래스의 멤버들을 다른 클래스 내에서 사용하기 위해서는 가장 먼저 클래스의 객체를 생성해야 했습니다.  이렇게 객체 안에 있을 때 사용할 수 있는 상태가 되는 멤버를 `인스턴스 멤버(instance member)`라고 합니다.

인스턴스 멤버는 static이 붙어 있지 않은 것을 말합니다.
따라서 반면 static이 붙은 멤버는 `정적 멤버(static memver)`라고 합니다.

> 정적 멤버의 가장 큰 특징은 객체의 생성 없이 `클래스명.멤버명`만으로 바로 사용할 수 있다는 것입니다.
다만, 정적 멤버도 인스턴스 멤버처럼 객체를 생성한 후 `참조 변수명.멤버명`과 같이 사용할 수 있지만, 그렇다면 굳이 정적 멤버를 만들 필요가 없기 때문에 `클래스명.멤버명`의 형태로 사용하길 권장합니다.

### 인스턴스 필드와 정적 필드
인스턴스 필드와 정적 필드는 저장 공간 위치가 다릅니다.
인스턴스 필드의 경우 힙 메모리 공간에 생성되는 반면, 정적 필드는 스택과 힙이 아닌 정적(static) 영역 내부에 생성됩니다.

> 따라서 인스턴스 필드의 실제값은 힙 메모리 영역, 참조 변수는 스택영역에 위치하는 반면, 정적 필드의 실제값은 정적(static) 영역, 참조값은 힙 영역(객체 내부)에 위치하고 있습니다.

```java
class A {
    int m = 3;
    static int n = 5;
}

// 인스턴스 필드 사용
A a = new A();
System.out.println(a.m);

// 정적 필드 사용
System.out.println(A.n);
```

> 반드시 기억해야 하는 정적 필드의 특징은 `정적 필드는 객체 간 공유 변수의 성질이 있다`는 것입니다.
즉, 인스턴스 필드와 정적 필드의 메모리 구조상 차이점을 정확히 구분해야 합니다.

- 이러한 이유로 정적 필드를 `클래스별로 관리하는 클래스 변수`라고 합니다.


### 인스턴스 메서드와 정적 메서드
인스턴스 메서드와 정적 메서드도 이전 필드와 동일하게 접근 및 호출할 수 있습니다.

- 차이점은 인스턴스 메서드와 정적 메서드 모두 메모리의 첫 번째 영역에 위치하지만, 인스턴스 메서드는 인스턴스 메서드 영역, 정적 메서드는 클래스 내부에 존재합니다.

> 메모리의 첫 번째 영역에는 클래스, 메서드, 정적 필드와 정적 메서드, 상숫값이 저장됩니다.
이렇게 다양한 데이터가 저장되기 때문에 클래스 영역, 메서드 영역, 정적 영역, 상수 영역이라는 여러 가지 이름으로 불립니다.


### 정적 메서드 안에서 사용할 수 있는 필드와 메서드
`정적 메서드 내부에서는 정적 멤버만 사용할 수 있습니다.`
이유는 정적 메서드는 객체 생성 없이 실행될 수 있어야 하기 때문입니다.

> 이를 프로그래밍 문법의 관점으로 설명하자면, 정적 메서드 내부에서는 클래스 내부에서 자신의 객체를 가리키는 this. 키워드를 사용할 수 없다는 것을 의미합니다.  따라서 this. 가 자동으로 붙어야 하는 인스턴스 멤버는 올 수 없습니다.
`정적 메서드 내부에서는 정적 멤버만 사용할 수 있습니다.`


### 정적 초기화 블록
일반적으로 인스턴스 필드의 초기화는 객체가 만들어지는 시점에서 이뤄집니다.
즉, 객체가 생성자에서 만들어지므로 생성자 내에서 인스턴스 필드를 초기화하는 것이 일반적입니다.
하지만, 정적 필드는 객체의 생성 이전에도 사용할 수 있어야 하므로 생성자가 호출되지 않는 상태에서도 초기화할 수 있어야 합니다.
다시 말해서, 생성자에서는 정적 필드는 초기화할 수 없다는 말이 됩니다.

때문에 정적 필드를 초기화하기 위한 문법을 별도로 제공하는데, 이를 정적 초기화 블록(static {})입니다.

```java
// 정적 초기화 블록
static {
    // 클래스가 메모리에 로딩될 때 실행되는 내용
}
```

정적 초기화 블록은 클래스가 메모리에 로딩될 때 가장 먼저 실행되므로 여기에 정적 필드의 초기화 코드를 넣어두면 클래스가 로딩되는 시점에 바로 초기화할 수 있습니다.

```java
class A {
    int a;
    static int b;

    static {
        b = 5;
        System.out.println("클래스 A가 로딩되었습니다.");
    }
    A() {
        a = 3;
    }
}

public class StaticInitialBlock {
    public static void main(String[] args) {
        System.out.println(A.b);
    }
}
```
output
```
클래스 A가 로딩되었습니다.
5
```


### static main() 메서드
지금까지 작성했던 `public static void main(String[] args)`도 정적 메서드입니다.
이전에도 언급했듯이 프로그램을 실행할 때 가장 먼저 실행되는 메서드가 main() 메서드이기 때문입니다.

실제로 JVM(Java Virtual Machine)은 `실행 클래스명.main()`을 실행하므로 가장 먼저 실행되는 메서드인 main() 메서드를 정적 메서드로 구성한 것입니다.

> A.java ->`(컴파일)`-> A.class ->`(실행)`-> JVM -> A.main() 실행
