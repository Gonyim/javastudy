# 3장 : 반복문, 배열

## 반복문
### 1. for 문
- 처음부터 반복 횟수를 알 수 있는 경우에 적합하다.  
#### <구조>
```java
for (초기문; 조건식; 반복 후 작업) {
    ...작업문...
}
```
***
* 초기문
    * 초기문은 시작할 때 한 번만 수행된다.
    * 콤마(,)로 분리하여 여러 문장을 나열할 수 있다.
    * 초기문은 빈 상태로 두어도 되지만 끝에 세미콜론(;)이 있어야 한다.
***
* 조건식
    * 논리형 변수나 논리 연산을 사용한다.
    * 조건식의 결과가 true이면 반복이 계속되고 false일 경우 for 문을 벗어난다.
    * 조건식에 true가 있거나 비어 있으면 무한 반복된다.  
#### <구조>
```java
⑴
for (초기문; true; 반복 후 작업) {
    ...작업문...
}

⑵
for (초기문; ; 반복 후 작업) {
    ...작업문...
}
```
***
* 반복 후 작업문은 콤마(,)로 분리하여 여러 문장을 나열할 수 있다.  
#### <예시>
```java
for (i=0; i<10; i++, System.out.println(i)) {
    ...작업문...
}
```
***
* 작업문이 하나의 문장인 경우 중괄호를 생략해도 되지만 여러 개의 문장으로 구성될 경우 반드시 중괄호가 필요하다.
#### <예시>
```java
⑴
for (i=0; i<10; i++)
    System.out.println(i);

⑵
for (i=0; i<10; i++) {
    System.out.println(i);
    System.out.println(i);
}
```
***
* 반복문 블록 내에서 선언된 지역변수는 반복문 밖에서는 사용할 수 없다.
***

### 2. while 문
- 반복 횟수를 알 수 없고 조건에 따라 반복이 계속되거나 중단되는 경우에 적합하다.
- 반복 조건을 처음부터 따지는 경우에 적합하다.  
#### <구조>
```java
while (조건식) {
    ...작업문...
}
```
* for 문과 달리, while 문에서는 조건식이 없으면 컴파일 오류가 발생한다.
* 조건식에 사용되는 변수를 while 문 실행 전에 초기화해야 한다.
* 반복이 진행되면서 조건식이 false가 되어 반복문을 빠져나올 수 있게 설계해야 한다. => 그렇지 않으면 무한 반복에 빠지게 된다.
***

### 3. do-while 문
- 반복 횟수를 알 수 없고 조건에 따라 반복이 계속되거나 중단되는 경우에 적합하다.
- 반복 조건을 나중에 따지는 경우에 적합하다.  
#### <구조>
```java
do {
    ...작업문...
} while(조건식);
```
* while 문과 동일하게 조건식이 없으면 컴파일 오류가 발생하며, 실행 이전에 사용되는 변수가 초기화되어야 하며, 무한 반복에 빠지지 않게 조건식이 false로 만들 수 있도록 설계되어야 한다.
* do-while 문은 다른 반복문과 달리 작업문 실행 후 조건식을 검사하므로 작업문이 최초 한 번은 반드시 실행한다.
***

### 4. 중첩 반복
* 반복문 안에 다른 반복문을 만들 수 있다.
* 많은 중첩 반복은 프로그램 구조를 복잡하게 하므로 3중 중첩 이상하지 않는 것이 바람직하다.

#### <예시>
```java
구구단

public class Gugudan {
    public static void main(String[] args) {
        for(int i=1; i<10; i++) {
            for(int j=1; j<10; j++) {
                System.out.print(i + "*" + j + "=" + i*j);
                System.out.print('\t');
            }
            System.out.println();
        }
    }
}
```
***

### 5. continue 문
- 반복문을 빠져나가지 않으면서 즉시 다음 반복으로 넘어가고자할 때 사용한다.
- for 문에서 continue 문을 만나면 '반복 후 작업'으로 분기하고, while 문이나 do-while 문에서는 조건식을 검사하는 과정으로 분기한다.

#### <예시>
```java
for(초기문; 조건식; 반복 후 작업) {
    ...                 ↑ 
    continue;───────────┘
    ...
}

while(조건식) {
    ...    ↑
    continue;
    ...
}

do {
    ...
    continue;
    ...    ↓
} while(조건식);
```
***

### 6. break 문
- break 문은 하나의 반복문만 벗어난다.

<예시>  
입력된 수 n이 5의 배수이거나 음수인 경우 while 문을 벗어나는 코드  
1. while 문의 조건식을 이용하는 경우
```java
int n = scanner.nextInt();
while(n > 0 && n % 5 != 0) {
    n = scanner.nextInt();
}
```
2. while 문의 조건식은 true로 하고 if 문으로 벗어나는 조건을 만드는 경우
```java
while(true) {
    int n = scanner.nextInt();
    if(n%5 == 0)
        break;
    if(n<0)
        break;
}
```
***

### 7. 배열
- 배열은 인덱스와 인덱스에 대응하는 데이터들로 이루어진 연속적인 자료 구조로서, 같은 종류의 데이터들이 순차적으로 저장된다.
```java
int i[] = new int[10];
```
|i[n]|데이터 값|
|---|---|
|i[0]|23|
|i[1]|4|
|i[2]|17|
|i[3]|98|
|.|.|
|.|.|
|i[9]|67|
|i[10]|20|
***

#### - 자바에서 배열 선언 및 생성
1. 배열에 대한 레퍼런스 변수 intArray 선언  
```java
int intArray [];
```
- int : 배열 타입
- intArray : 배열에 대한 레퍼런스 변수
- [] : 배열 선언

2. 배열 생성
```java
intArray = new int [n];
```
- intArray : 배열에 대한 레퍼런스 변수
- new : 배열 생성
- int : 타입
- [n] : 원소 개수
***

#### - 배열에 대한 레퍼런스 변수 선언
- int intArray []; 선언만으로 배열 공간이 할당되지 않으므로 intArray값은 null이다.
- 배열의 주소를 레퍼런스라고 하며, 배열에 대한 주소 값을 가지는 변수를 레퍼런스 변수라고 한다.
- int intArray []; 방법과 int [] intArray; 방법 둘 다 가능하다.
- 배열 선언 시 []안에 크기를 지정해서는 안 된다.  
<예시>
```java
int intArray [10];  // 컴파일 오류
```
- 배열을 생성할 때는 반드시 new 연산자를 이용해야 한다.
***

#### - 배열 인덱스와 배열 원소 접근
- 배열의 인덱스는 정수만 가능하며, 인덱스는 0부터 시작한다.
***

#### - 레퍼런스 치환과 배열 공유
- 자바에서는 레퍼런스 변수와 배열 공간이 분리되어 있기 때문에, 다수의 레퍼런스 변수가 하나의 배열 공간을 가리키는 배열 공유가 쉽게 이루어진다.  
<예시>
```java
int intArray[] = new int[5];
int myArray[] = intArray;
intArray[1] = 2;
myArray[1] = 6;
System.out.println(intArray[1]);
--------------------------------
결과값 : 6
```
- 레퍼런스 즉 배열에 대한 주소만 복사되기 때문에 myArray는 intArray와 동일한 레퍼런스 값을 가지게 되어 myArray는 intArray와 배열을 공유하게 되고, myArray로 intArray의 배열 원소에 마음대로 접근할 수 있다.
***

#### - 배열의 크기
- 자바에서 배열은 객체로 다룬다.(객체의 설명은 4장에서...)
- length필드를 이용해 배열의 크기를 알 수 있다.  
<예시>
```java
int intArray[] = new int[5];
int size = intArray.length;
System.out.println(size);
-------------------------
결과값 : 5
```
***

#### - 배열과 for-each 문
- 기존의 for 문을 변형하여 배열이나 나열의 크기만큼 루프를 돌면서 각 원소를 순차적으로 접근하는데 유용하게 만든 for 문을 for-each 문(오라클에서는 advanced for)이라고 부른다.

<구조>
```java
for (변수 : 배열레퍼런스) {
    ...반복작업문...
}
```
<예시1>
```java
int [] n = {1, 2, 3, 4, 5};
int sum = 0;
for(int k : n) {
    sum += k;
}
System.out.println(sum);
```
<예시2>
```java
int [] n = {1, 2, 3, 4, 5};
int sum = 0;
for(int k : n) {
    sum += k;
}
System.out.println(sum);
```
- 배열뿐만 아니라 나열 타입(enum)에도 for-each 문이 사용된다.
***

### 8. 다차원 배열
- 3차원 이상의 배열은 특별한 경우에만 사용하고, 자바의 다차원 배열은 C/C++과는 다르게 독특한 구조를 가진다.

#### - 2차원 배열의 선언과 생성
- 2차원 배열의 레퍼런스 변수 선언
```java
int intArray [][];
char charArray [][];
double doubleArray [][];
또는
int [][]intArray;
char [][]charArray;
double [][]doubleArray;
```
- 2차원 배열의 저장 공간 생성
```java
int intArray[][] = new int [행][열];
char charArray[][] = new char [행][열];
double doubleArray [][] = new double [행][열];
```
- 2차원 배열의 레퍼런스 변수 선언과 저장 공간 생성을 동시에 실행
```java
int intArray [][] = new int [행][열];
char charArray [][] = new char [행][열];
doubleArray = new double [행][열];
```
***

- i.length : 2차원 배열의 행의 개수
- i[n].length : n번째 행에 있는 열의 개수
***

#### - 비정방형 배열
- 비정방형 배열은 행마다 열의 개수가 서로 다른 배열을 뜻한다.
- 비정방형 배열의 작성 코드
```java
int i [][];
i = new int [4][]; // 레퍼런스 배열 생성
i[0] = new int [1]; // 첫째 행에 1개 크기의 배열 생성
i[1] = new int [2]; // 둘째 행에 2개 크기의 배열 생성
i[2] = new int [3]; // 셋째 행에 3개 크기의 배열 생성
i[3] = new int [4]; // 넷째 행에 4개 크기의 배열 생성
```
|비|정|방|형|
|---|---|---|---|
|i[0][0]||||
|i[1][0]|i[1][1]|||
|i[2][0]|i[2][2]|i[2][2]||
|i[3][0]|i[3][1]|i[3][2]|i[3][3]|

위의 배열의 length 필드를 알아본다
- i.length : 2차원 배열의 행의 개수, 4
- i[0].length : 0번째 행의 열의 개수, 1
- i[1].length : 1번째 행의 열의 개수, 2
- i[2].length : 2번째 행의 열의 개수, 3
- i[3].length : 3번째 행의 열의 개수, 4

**어떤 메소드가 배열을 매개변수로 받을 때, 배열이 정방형인지 비정방형인지 표시되지 않기 때문에 항상 length필드를 사용하여 각 행의 열의 개수를 파악하여야 한다.**
***

- 2차원 배열의 초기화를 통한 생성
```java
int intArray[][] = { {0,1,2}, [3,4,5], {6,7,8} }; // 3*3 배열 생성
char charArray[][] = { {'a', 'b', 'c'}, {'d','e','f'} }; // 2*3 배열 생성
```
- 비정방형 배열의 초기화를 통한 생성
```java
int intArray[][] = { {0}, {1,2}, {3,4,5}, {6,7,8,9} };
```
- 비정방형 배열 생성 방법으로 정방형 배열을 만들 수 있다.
```java
int i [][];
i = new int [4][]; // 레퍼런스 배열 생성
i[0] = new int [4]; // 첫째 행에 4개 크기의 배열 생성
i[1] = new int [4]; // 둘째 행에 4개 크기의 배열 생성
i[2] = new int [4]; // 셋째 행에 4개 크기의 배열 생성
i[3] = new int [4]; // 넷째 행에 4개 크기의 배열 생성
```