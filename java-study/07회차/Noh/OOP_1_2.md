# 객체지향 프로그래밍
## 오버로딩(overloading)
### 오버로딩이란?
* 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩(method overloading)' 또는 간단한 '오버로딩(overloading)'이라 한다
* 메서드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 하기 때문에 각기 다른 이름을 가져야한다
    * 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다

### 오버로딩의 조건
* 같은 이름의 메서드를 정의한다고 해서 무조건 오버로딩인 것은 아니다
```java
1. 메서드 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야 한다
```

* 메서드의 이름이 같다 하더라도 매개변수가 다르면 서로 구별될 수 있기 때문에 오버로딩이 가능한 것이다
* 1번과 2번의 조건을 만족시키지 못하는 메서드는 중복 정의로 간주되어 컴파일 시에 에러가 발생한다
  * 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로 **반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다**는 것에 주의하자

### 오버로딩의 예

* `println` 메서드는 오버로딩(overloading)의 대표적인 예입니다.
* `println` 메서드는 자바의 표준 출력 스트림(standard output stream)인 `System.out`을 통해 문자열을 출력하는 메서드입니다

* `println` 메서드도 다양한 형태로 오버로딩되어 있어서 여러 종류의 데이터를 출력할 수 있습니다
  * 10개의 오버로딩된 println메서드 정의가 있다
1. `void println()`: 인자 없이 아무 내용도 출력하지 않고 줄바꿈합니다.
2. `void println(boolean x)`: 불리언 값을 출력하고 줄바꿈합니다.
3. `void println(char x)`: 문자를 출력하고 줄바꿈합니다.
4. `void println(int x)`: 정수를 출력하고 줄바꿈합니다.
5. `void println(long x)`: long 정수를 출력하고 줄바꿈합니다.
6. `void println(float x)`: 부동 소수점을 출력하고 줄바꿈합니다.
7. `void println(double x)`: 더블 부동 소수점을 출력하고 줄바꿈합니다.
8. `void println(char[] x)`: 문자 배열을 출력하고 줄바꿈합니다.
9. `void println(String x)`: 문자열을 출력하고 줄바꿈합니다.
10. `void println(Object x)`: 객체를 출력하고 줄바꿈합니다.
```java
public class PrintlnExample {
    public static void main(String[] args) {
        System.out.println("Hello, World!"); // 문자열 출력
        System.out.println(42); // 정수 출력
        System.out.println(3.14); // 실수 출력
        System.out.println(true); // 불리언 값 출력
        char letter = 'A';
        System.out.println(letter); // 문자 출력
    }
}
``` 

ex1)
```java
int add(int a, int b) { return a+b; }
int add(int x, int y) { return x+y; }
```
* 매개변수의 이름만 다를 뿐 매개변수의 타입이 같기 때문에 오버로딩이 성립하지않는다
  * 매개변수의 이름이 다르면 메서드 내에서 사용되는 변수의 이름이 달라질 뿐, 아무런 의미가 없다 -> 같은 메서드임
    * 컴파일하면, 'add(int,int) is already defined(이미 같은 메서드가 정의되었다.)'라는 메세지가 나타날 것이다

ex2)
```java
int add(int a, int b) { return a+b; }
long add(int a, int b) { return (long)(a+b; )}
```
* 리턴타입만 다른 경우이다
  * 매개변수의 타입과 개수가 일치하기 때문에 add(3,3)과 같이 호출하였을 때 어떤 메서드가 호출된 것인 지 결정할 수 없기 때문에 오버로딩으로 간주되지 않는다
    * 컴파일하면, 'add(int,int) is already defined(이미 같은 메서드가 정의되었다.)'라는 메세지가 나타날 것이다

ex3)
```java
long add(int a, long b) { return a+b; }
long add(long a, int b) { return a+b; }
```
* 두 메서드 모두 int형과 long형 매개변수가 하나씩 선언되어 있지만, 서로 순서가 다른 경우이다
  * 호출 시 매개변수의 값에 의해 호출될 메서드가 구분될 수 있으므로 중복된 메서드 정의가 아닌, 오버로딩으로 간주한다
  ### 오버로딩의 장점
* 메서드가 변수처럼 단지 이름만으로 구별된다면, 한 클래스 내의 모든 메서드들은 이름이 달라야한다
```java
void println()
void printlnBoolean(boolean x)
void printlnChar(char x)
```
  * 모두 근본적으로는 같은 기능을 하는 메서드들이지만, 서로 다른 이름을 가져야하기 때문에 메서드를 작성하냐는 쪽에서는 이름을 짓기도 어렵고, 메서드를 사용하는 쪽에서는 이름을 일일이 구분해서 기억해야하기 때문에 서로 부담이 된다
    * 오버로딩을 통해 여러 메서드들이 println이라는 하나의 이름으로 정의될 수 있다면, println이라는 이름만 기억하면 되므로 기억하기도 쉽고 이름도 짧게 할 수 있어서 오류의 가능성을 많이 줄일 수 있다
      * 메서드의 이름만 보고도 '이 메서드들은 이름이 같으니, 같은 기능을 하겠구나.' 라고 쉽게 예측할 수 있게 된다
## 생성자(constructor)
* 생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다
  * 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 하는 작업을 위해서도 사용된다
* 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만 리턴값이 없다는 점이 다르다
  * 그렇다고 해서 생성자 앞에 리턴값이 없음을 뜻하는 키워드 void를 사용하지는 않고, 단지 아무 것도 적지 않는다
```java
1. 생성자의 이름은 클래스의 이름과 같아야 한다
2. 생성자는 리턴 값이 없다
```
  * 생성자도 메서드이기 때문에 리턴값이 없다는 의미의 void를 붙여야하지만, 묻는 생성자가 리턴값이 없으므로 void를 생략할 수 있게 한 것이다

* 생성자도 오버로딩이 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있습니다
```java
클래스이름(타입 변수명, 타입 변수명, ...) {
    // 인스턴스 생성 시 수행될 코드,
    // 주로 인스턴스 벼수의 초기화 코드를 적는다
        }
```
```java
class Card {
    Card() { // 매개변수가 없는 생성자
      ...
    }
    Card(String k, int num) { // 매개변수가 있는 생성자
      ...
    }
  ...
}
```
### 기본 생성자(default constructor)
* 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다
  * 지금까지 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 '기본 생성자(default construcor)' 덕분이었다
```java
클래스이름() { }
Card () { }
```
* 컴파일 할 때,  소스파일(*.java)의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일 한다
  * 컴파일러가 자동적으로 추가해주는 기본 생성자는 매개변수도 없고 아무런 내용도 없는 아주 간단한 것이다
    * 특별히 인스턴스 초기화 작업이 요구되어지지 않는다면 생성자를 정의하지 않고 컴파일러가 제공하는 기본 생성자를 사용하는 것도 좋다
```java
기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의도니 생성자가 하나도 없을 때 뿐이다
```
### 매개변수가 있는 생성자
* 생성자도 메서드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용할 수 있다
  * 인스턴스마다 각기 다른 값으로 초기화되어야 하는 경우가 많기 때문에 매개변수를 사용한 초기화는 매우 유용하다
```java
Car {
    String color; // 색상
    String gearType; // 변속기 종류 - auto(자동), manual(수동)    
    int door; // 문의 개수 
    
    Car() { } // 컴파일러에 의해 추가된 기본 생성자. 내용이 없다.
    Car(String c, String g, int d){ // 생성자
        color = c;
        gearType = g;
        door = d;
        }    
}
```
* Car인스턴스를 생성할 때, 생성자 Car()를 사용한다면, 인스턴스를 생성한 다음에 인스턴스 변수들을 따로 초기화해주어야 하지만, 매개변수가 있는 생성자 Car(String color, String gearType, int door)를 사용한다면 인스턴스를 생성하는 동시에 원하는 값으로 초기화를 할 수 있게 된다
  * 인스턴스를 생성한 다음에 인스턴스 변수의 값을 변경하는 것보다 매개변수를 갖는 생성자를 사용하는 것이 코드를 보다 간결하고 직관적으로 만든다
```java
Car c = new Car();
c.color = "white";
c.gearType = "auto";
c.door = 4;
```
```java
Car c = new Car("white", "auto", 4);
```
* 클래스를 작성할 때 다양한 생성자를 제공함으로써 인스턴스 생성 후에 별도로 초기화를 않아도 되게 하는 것이 바람직하다
### 생성자에서 다른 생성자 호출하기 - this()
* 같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다
* 조건
```java
1. 생성자의 이름으로 클래스이름 대신 this를 사용한다
2. 한 생성자에서 다른 생성자를 호출할 대는 반드시 첫 줄에서만 호출이 가능하다
```
```java
Car(String color) {
    door = 5; // 첫번재 줄
    Car(color, "auto", 4); // 에러1, 생성자의 두 번째 줄에서 다른 생성자 호출
        } // 에러2, this(color, "auto", 4);로 해야함
```
* 생성자에서 다른 생성자를 첫 줄에서만 호출이 가능하도록 한 이유는 생성자 내에서 초기화 작업 도중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있개 때문이다

## 변수의 초기화
### 변수의 초기화
* 변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 한다
* 변수의 초기화는 경우에 따라서 필수적이기도 하고 선택적이기도 하지만, 가능하면 선언과 동시에 적절한 값으로 초기화 하는 것이 바람직하다
* 멤버변수는 초기화를 하지 않아도 자동적으로 벼수의 자료형에 맞는 기본값으로초기화가 이루어지므로 초기화하지 않고 사용해도 되지만, 지역변수는 사용하기 전에 반드시 초기화해야 한다
```java
class InitTest {
    int x; // 인스턴스변수
    int y = x; // 인스턴스변수
  
    void method1() {
        int i; // 지역변수
        int j = i; // 에러, 지역변수를 초기화하지 않고 사용
    }
}
```
* x와 i는 선언만 하고 초기화를 하지 않았다
* y를 초기화 하는데 x를 사용하였고, j를 초기화 하는데 i를 사용하였다
* 인스턴스 변수 x는 초기화를 해주지 않아도 자동적으로 int형의 기본값인 0으로 초기화되므로, 'int y = x;'와 같이 할 수 있다. x의 값이 0이므로 y역시 0이 저장된다
* method1()의 지역변수 i는 자동적으로 초기화되지 않으므로, 초기화 되지 않은 상태에서 변수 j를 초기화 하는데 사용될 수 없다. 컴파일하면, 에러가 발생한다
```java
멤버변수(클래스변수와 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다
```
#### 멤버변수의 초기화
* 지역변수와 달리 멤버변수는 각 타입의 기본값으로 자동 초기화된다
  * 그 다음에 명시적 초기화, 초기화 블럭, 생성자의 순서로 초기화 된다
    * 그리고 클래스 변수(cv)가 인스턴스 변수(iv)보다 먼저 초기화 된다
```java
1. 클래스 변수(cv) 초기화 -> 인스턴스 변수(iv) 초기화
2. 자동 초기화 -> 명시적 초기화(간단) -> 초기화 블럭, 생성자(복잡)
```
### 명시적 초기화(explicit initialization)
* 변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 한다
* 가장 기본적이면서도 간단한 초기화 방법이므로 여러 초기화 방법 중에서 가장 우선적으로 고려되어야 한다
```java
class Car {
    int door = 4; // 기본형(primitive type) 변수의 초기화
    Engine e = new Engine();// 참조형(reference type) 변수의 초기화
  // ...
}
```
* 명시적 초기화가 간단하고 명료하긴 하지만, 보다 복잡한 초기화 작업이 필요할 때는 '초기화 블럭(initialization block)' 또는 생성자를 사용해야 한다
### 초기화 블럭(initialization block)
* 초기화 블럭에는 '클래스 초기화 블럭'과 '인스턴스 초기화 블럭' 두 가지 종류가 있다
* 클래스 초기화 블럭은 클래스 변수의 초기화에 사용되고, 인스턴스 초기화 블럭은 인스턴스변수의 초기화에 사용된다
```java
클래스 초기화 블럭 : 클래스 변수의 복잡한 초기화에 사용된다
인스턴스 초기화 블럭 : 인스턴스 변수의 복잡한 초기화에 사용된다
```
* 초기화 블럭을 작성하려면, 인스턴스 초기화 블럭은 단순히 클래스 내에 블럭{} 만들고 그 안에 코드를 작성하기만 하면 된다
  * 클래스 초기화 블럭은 인스턴스 초기화 블럭 앞에 단순히 static을 덧붙이기만 하면 된다