# 클래스 내부 구성 요소

## 필드

### 필드와 지역 변수의 구분
필드(field)는 `클래스에 포함된 변수`로, 객체의 속성값을 지정할 수 있습니다.
이와 비슷한 지역변수(local variable)은 `메서드에 포함된 변수`입니다.
필드와 지역변수의 가장 큰 차이점은 생성되는 메모리의 위치입니다.

- 필드는 힙 메모리의 객체 내부에 생성되고, 지역변수는 스택 메모리에 생성됩니다.

스택 메모리에 저장되는 지역변수는 때가 되면 JVM이 자동으로 삭제하지만, 힙 메모리의 객체 안에 저장되는 필드는 객체가 사라지지 않는 한 절대로 삭제되지 않습니다.

> 객체가 더 이상 사용되지 않을 때, 즉 어떤 참조 변수도 해당 객체를 가리키지 않을 때 가비지 컬렉터가 객체 자체를 제거합니다.

> 1개의 메서드 안에 선언된 모든 지역변수들의 집합을 `프레임(frame)`이라고 합니다.

> 스택 메모리는 나중에 들어간 것이 먼저 나오는 LIFO(Last In First Out) 구조입니다.

### 필드와 지역 변수의 초깃값
필드와 지역변수의 또 다른 차이점은 초깃값입니다.
필드는 초기화하지 않아도 강제로 초기화 하는 반면, 지역변수는 초기화하지 않으면 빈 공간이 되어 출력하고자 할 때 오류가 발생됩니다.
이는 사실 필드와 지역변수의 저장공간 특성상 나타나는 차이점으로, 필드값은 힙 메모리에 저장되고, 힙 메모리는 강제로 초기값을 가지는 반면 지역변수는 스택 메모리에 저장되고, 스택 메모리는 강제 초깃값을 주지 않기 때문입니다.

## 메서드

### 메서드 정의하기
메서드는 클래스의 기능에 해당하는 요소입니다.

```Java
// 메서드 정의
자바 제어자 리턴(반환) 타입 메서드명(입력매개변수) {
    메서드 내용
}

// 예
public static int sum(int a, int b) {
    return a + b;
}
```

> 리턴 타입이 void가 아닐 때 메서드 안에는 반드시 `return 리턴값`의 코드가 있어야 합니다.
그렇지 않을 경우 오류가 발생됩니다.

### 여러 리턴 타입의 메서드 살펴보기
3가지의 메서드를 살펴보겠습니다.

1. 리턴 타입이 void이고, 입력매개변수가 없는 메서드

```Java
void print() {
    System.out.println("안녕");
}
```

2. 리턴 타입이 int이고, 입력매개변수가 없는 메서드

```Java
int data() {
    return 3;
}
```

3. 리턴 타입이 double이고, 입력매개변수가 2개인 메서드

```Java
double sum(int a, double b) {
    return a + b;
}
```

> void 리턴 타입은 리턴(반환)하지 않는다는 의미이지만 내부에 return 키워드를 사용할 수 있으며, 이는 `메서드를 종료한다`는 의미입니다.

### 메서드 호출하기
정의한 메서드를 호출할 때 외부와 내부 2가지 방법이 있습니다.

- 클래스 외부에서 메서드 호출하기
먼저 객체를 생성하고 참조 변수를 이용하여 메서드를 호출합니다.

- 클래스 내부에서 메서드 호출하기
내부에 있는 메서드끼리는 객체를 생성하지 않고 서로를 호출할 수 있습니다. 이유는 같은 멤버이기 때문입니다.
다만, 메서드 앞에 static이 붙어 있을 때는 static이 붙은 필드 또는 메서드만 호출할 수 있습니다.

또한 기존 방법을 제외한 입력매개변수에 따라 2가지 방법이 있습니다.

- 입력매개변수가 배열인 메서드 호출하기

```Java
public static void printArray(int[] a) {
    System.out.println(Arrays.toString(a));
}

public static void main(String[] args) {
    printArray(new int[] {1, 2, 3});    // O
    printArray({1, 2, 3})               // X
}
```

- 기본 자료형 입력매개변수와 참조 자료형 입력매개변수의 차이
여기서 기억해야될 것은 배열과 같은 참조 자료형이 입력매개변수로 넘겨질 때 실제 객체가 전달되는 것이 아니라 `객체의 위칫값이 전달`됩니다.
반대로 기본 자료형의 경우 값이 메서드의 지역변수에 복사됩니다.
따라서 `기본 자료형을 선언한 뒤에 변수를 전달하게 되면, 변수를 복사한 값이므로, 메서드가 종료되면 스택 메모리 영역에 남아있는 필드값도 사라지게 되므로 선언된 기본 자료형의 값은 변하지 않습니다.`
따라서 참조 자료형을 입력매개변수로 전달하게 되면 힙 메모리 영역의 주소값을 담은 스택 메모리 영역이 복사되어 같은 값을 바라보기 때문에 값이 변합니다.

### 오버로딩된 메서드
메서드 오버로딩을 이해하기 위해서는 먼저 `메서드 시그니처(method signature)`의 의미를 알아야 합니다.
메서드 시그니처는 메서드명과 입력매개변수의 자료형을 말하며, 시그니처(서명)라는 말에서 유추할 수 있듯이 메서드를 구분하는 기준 역할을 합니다.
JVM은 메서드 시그니처가 다르면 메서드명이 동일해도 다른 메서드로 인식합니다. 
`메서드 오버로딩(method overloading)`은 이러한 특징을 이용한 것으로 입력매개변수의 개수나 자료형이 다른 여러 개의 동일한 이름을 지닌 메서드를 같은 공간에 정의하는 것을 말합니다.

오버로딩된 메서드의 호출은 앞에서 배운 메서드 호출과 똑같습니다.
따라서 입력매개변수에 따라 실제 어떤 메서드가 호출된 것인지만 구분해주면 됩니다.

### 가변 길이 배열 입력매개변수 메서드
이는 어떤 메서드가 입력매개변수로 수많은 값을 받는다고 가정해 보면 그 많은 오버로딩 메서드를 정의해야되는 골치아픈 일이 발생됩니다.
때문에 이를 간단하게 할 수 있는 방법이 `가변 길이 배열 입력매개변수`입니다.
즉 개수가 정해지지 않은 배열로, 이 배열의 크기는 함수가 호출될 때 전달된 입력값의 개수로 정해집니다.

```Java
// 가변 길이 배열 입력매개변수
리턴 타입 메서드명 (자료형... 참조 변수명) {
    ...
}
// 예
public static int sum(int... values) {
    int sum = 0;

    System.out.print("모두 합한 값: ");
    for (int i = 0; i < values.length; i++) {
        sum += values[i];
    }
    System.out.println(sum);
    return sum;
}
```

가변 길이 배열 입력매개변수를 사용하면 단 1개의 메서드만 정의해 해결할 수 있습니다.
대부분의 문법이 그렇듯이 메서드 오버로딩의 불편함을 덜고자 만들어진 문법입니다.

## 생성자
`생성자(constructor)`는 `객체를 생성하는 역할을 지닌` 클래스의 내부 구성 요소입니다.
또한, 객체 내부에 포함된 필드의 초기화 또한 주로 생성자 내에서 수행합니다.

### 생성자의 특징
생성자를 작성할 때 꼭 지켜야 하는 문법 규칙은 2가지가 있습니다.

- 첫 번째는 `반드시 클래스명과 동일한 이름`으로 지어야 합니다.

- 두 번째는 메서드와 비슷한 구조를 지니고 있지만, `리턴 타입이 없습니다.`

```Java
// 생성자의 문법 구조
클래스명(입력매개변수) {
    ...
}

// 예
class A {
    A(){
        ...
    }
    ...
}
```

### 기본 생성자의 자동 추가
지금까지 생성자를 만들지 않아도 정상적으로 객체가 생성됐던 이유는 생성자를 포함하지 않는 클래스는 컴파일러가 기본 생성자를 추가해주기 때문입니다.
여기서 기본 생성자는 입력매개변수가 없는 생성자를 말합니다.

대표적인 붕어빵과 붕어빵틀로 비유하자면, 클래스는 붕어빵틀, 객체는 붕어빵이면 생성자는 붕어빵을 찍는 기능 정도라고 생각할 수 있습니다.
따라서 생성자가 없는 클래스는 객체를 생성할 수 없는 클래스로 전혀 존재 이유가 없는 것입니다.

그러므로 컴파일러는 생성자가 없는 클래스를 만들면 적어도 1개의 생성자가 필요하므로 입력매개변수가 없는 기본 생성자를 추가해줍니다.

생성자가 호출되는 것만으로 객체가 내부적으로 생성도비니다.
생성자의 실행문, 즉 생성자의 중괄호 안은 객체가 생성된 이후 할 일이 작성됩니다.
일반적으로 여기에서 필드를 초기화 합니다.
따라서 컴파일러가 추가해 주는 기본 생성자 안은 텅 비어있습니다.

하지만, 사용자가 입력매개변수가 있는 생성자를 만들어도 객체는 생성할 수 있기 때문에 기본 생성자를 추가해주지 않습니다.

### 생성자와 객체의 생성 방법
메서드와 마찬가지로 자료형과 입력매개변수 개수에 따라 객체를 생성하는 방법이 결정됩니다.

> 가변 길이 배열 입력매개변수로 메서드를 만든것 처럼 생성자를 만들 수 있는지 알아보자

## this 키워드와 this() 메서드
클래스의 외부에서 멤버(필드, 메서드, 이너 클래스)를 호출하기 위해서는 객체를 먼저 생성한 뒤 `참조 변수명.멤버명`의 형태로 호출하지만, 클래스 내부에서는 객체의 생성 없이 필드와 메서드를 바로 사용할 수 있다고 했습니다.
하지만 `모든 사용할 수 있는 상태의 멤버는 항상 객체 속에만 존재`합니다.
그렇다면 어떻게 클래스 내부에서는 객체를 생성하지 않고 바로 필드와 메서드를 사용하는지 알아보겠습니다.

### 내부 객체 참조 변수명인 this 키워드
`모든 메서드에는 자신이 포함된 클래스의 객체를 가리키는 this라는 참조 변수가 있습니다.`
따라서 모든 멤버는 객체 속에서 존재하는 것이므로 예를 들어 `int a = 3;`이라는 필드를 클래스 내부에서 출력하고자 할 때도 `System.out.println(this.a)`처럼 작성해야 합니다.

`this.를 생략하면 컴파일러가 자동으로 this.를 추가해줍니다.` 다만, 지역변수는 멤버가 아니므로 this.가 자동으로 붙지 않습니다.

내용을 다시 한번 정리하면 모든 멤버는 활용할 때 소속과 함꼐 표기(참조 변수명.멤버명)해야 하며, 클래스 내부에서 멤버를 활용할 때 소속을 표기하지 않으면 컴파일러가 자동으로 소속(this.)을 붙여 줍니다.

> 여기서 주의해야 할 점은 지역변수명과 필드명이 동일할 경우, this.를 필수적으로 작성해줘야 합니다.
이유는 작성하지 않게 되면 가장 가까운 지역변수로 인식하여 필드값으로 대입을 하지 못하는 이슈가 발생되기 때문입니다.
`자바에서 제공하는 대부분의 API에는 메서드의 지역변수명이 필드명과 동일하게 구성돼 있습니다.`

### 클래스 내 다른 생성자를 호출하는 this() 메서드
`this() 메서드`는 this. 키워드와 매우 유사하게 생겼지만, 전혀 다른 의미를 가지고 있습니다.
this() 메서드는 `자신이 속한 클래스 내부의 다른 생성자를 호출`하는 명령입니다.
예를 들어 클래스명이 A라면 this()는 A() 생성자를 호출하는 것이라고 생각할 수 있습니다.
때문에 만약 this(3)이라면 A(3), 즉 int 데이터 하나를 입력받는 생성자를 호출하는 것입니다.

this() 메서드를 구성할 때는 반드시 2가지 문법적 규칙이 있습니다.

- 첫 번째는 `생성자의 내부에서만 사용할 수 있습니다.`
즉, 생성자의 내부에서만 다른 생성자를 호출할 수 있습니다.

- 두 번째는 `생성자의 첫 줄에 위치해야 합니다.`

이 둘 중 어느 하나라도 지켜지지 않으면 이클립스는 바로 오류를 발생시킵니다.

this() 메서드가 생긴 이유는 개발자의 편리함을 위해서입니다.

예를 들어 필드가 4개이고 생성자가 3개인 클래스가 있다고 가정하겠습니다.

예를 들어 기본 생성자는 필드 4개의 값을 초기값을 넣어주고, 두 번째, 세 번째 생성자는 각각 필드의 첫 번째, 두 번째의 값만 입력매개변수로 값을 변경하고 나머지는 동일하게 초기값을 넣어줬을 때, 하드코드로 작성하게 되면 너무 많은 줄의 코드를 입력하게 될 것입니다.
따라서 두 번째, 세 번째 생성자의 첫 번째 줄에 this() 메서드를 사용하여 다른 값을 초기화 하고 나머지 필드값만 추가해주면 다음과 같이 생성자의 중복을 제거할 수 있기 때문입니다.

```Java
class A {
    int m1, m2, m3, m4;
    A() {
        m1 = 1;
        m2 = 2;
        m3 = 3;
        m4 = 4;
    }
    A(int a) {
        m1 = a;
        m2 = 2;
        m3 = 3;
        m4 = 4;
    }
    A(int a, int b) {
        m1 = a;
        m2 = b;
        m3 = 3;
        m4 = 4;
    }
}


class A {
    int m1, m2, m3, m4;
    A() {
        m1 = 1;
        m2 = 2;
        m3 = 3;
        m4 = 4;
    }
    A(int a) {
        this()
        m1 = a;
    }
    A(int a, int b) {
        this()
        m1 = a;
        m2 = b;
    }
}
```
