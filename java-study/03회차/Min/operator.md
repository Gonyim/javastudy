# 연산자

## 연산자의 종류

자바의 연산자는 연산 결과에 따른 3가지의 특징이 있습니다.
첫째, 연산 결과가 특정 값이 나오는 산술, 증감, 비트, 시프트 연산자,
둘째, 연산 결과가 참(true)과 거짓(false) 중 하나의 값으로만 나타나는 비교, 논리 연산자,
셋째, 값을 반환하는 것이 아닌값을 대입하는 의미를 지니고 있는 대입 연산자와 삼항 연산자가 있습니다.

| 자료형        	| 연산 기호                                  	| 기능                                              	| 결과         	|
|---------------	|--------------------------------------------	|---------------------------------------------------	|--------------	|
| 산술 연산자   	| +, -, *, /, %                              	| 사칙연산 및 나머지 연산                           	| 값           	|
| 증감 연산자   	| ++, - -                                    	| 값이 1씩 증가 및 감소                             	|              	|
| 비트 연산자   	| &, \|, ~, ^                                	| 비트 AND, OR, NOT, XOR                            	|              	|
| 시프트 연산자 	| >>, <<, >>>                                	| 비트 단위의 이동                                  	|              	|
| 비교 연산자   	| <, >, <=, >=, ==, !=                       	| 값의 크기 비교                                    	| 참 또는 거짓 	|
| 논리 연산자   	| &&, \|\|, !, ^                             	| 논리 AND, OR, NOR, XOR                            	|              	|
| 대입 연산자   	| =, +=, -=, *=, /=, &=, \|=, >>=, <<=, >>>= 	| 산술 연산 결과의 대입 (‘연산자’ + ‘=’의 축약 표현 	| 실행         	|
| 삼항 연산자   	| (참 또는 거짓) ? x : y                     	| 참일 때 x, 거짓일 때 y                            	|              	|


## 연산자의 연산 방법

### 산술 연산자와 증감 연산자

산술 연산을 하면서 주의해야 할 점은, '정수/정수' 형태의 나누기(/)를 할 때, 자료형 간의 연산이기 때문에 'int/int = int'으므로 예를 들어 5 / 2 는 2.5가 아니라 2가 나옵니다.
또한 나머지 연산(%)은 말 그대로 나누기를 수행한 이후의 나머지를 나타내는데 이를 `모듈로(modulo) 연산`이라고 합니다.

증감 연산자는 변숫값을 1씩 증가 또는 감소하는 연산자입니다.
이는 변수값을 1씩 증가 또는 감소할 일이 매우 많아 코드의 간결함을 위해 생긴 연산자 입니다.
증감 연산자는 변수 앞에 붙는 `전위형`과 변수 뒤에붙는 `후위형`으로 나뉘며, 차이점은 `실행의 우선순위`입니다.

```Java
int a = 3;
int b = ++a;

System.out.println(a);  // 4
System.out.println(b);  // 4

int c = 3
int d = c++;

System.out.println(c);  // 4
System.out.println(d);  // 3
```

위 코드를 보면 `전위형`은 증감 연산을 먼저 실행한 후에 대입 연산을 싱행하기 때문에 a와 b값 모두 4인것을 확인할 수 있습니다.
하지만 `후위형`은 대입 연산을 먼저 실행하고 증감하기 때문에 c의 값은 4, 대입이 먼저된 d의 값은 3인것을 확인할 수 있습니다.

### 비트 연산자

비트 AND(&)는 두 값이 모두 1일 때만 1인 연산자이며, 비트 OR(|)은 두 값이 모두 0일 때만 0인 연산자입니다.
비트 XOR(^)은 두 값이 같을 때 0, 다를 때 1의 값을 가지며, 비트 NOT(~)은 0은 1, 1은 0으로 반전하는 연산자 입니다.

- 비트 연산 과정
비트 단위의 연산을 직접 계싼하기 위해서는 10진수를 비트 단위의 표현 방식인 2진수로 바꿔 표기할 수 있어야 합니다.
실제 수학적으로 변환하는 과정은 다루지 않으며, 진법 변환은 Java의 메서드로 아래와 같이 알아낼 수 있습니다.

| 기능                                 	| 메서드(method)           	|
|--------------------------------------	|--------------------------	|
| 10진수 -> 2진수                      	| Integer.toBinaryString() 	|
| 10진수 -> 8진수                      	| Integer.toOctalString()  	|
| 10진수 -> 16진수                     	| Integer.toHexString()    	|
| (2진수 \| 8진수 \| 16진수) -> 10진수 	| Integer.parseInt()       	|


```
// 비트 AND 연산자

   00000011 <- 3(10진수)
 & 00001010 <- 10(10진수)
 -----------
   00000010 -> 2(10진수)


// 비트 OR 연산자

   00000011 <- 3(10진수)
 | 00001010 <- 10(10진수)
 ----------
   00001011 -> 11(10진수)


// 비트 XOR 연산자

   00000011 <- 3(10진수)
 ^ 00001010 <- 10(10진수)
 ----------
   00001001 -> 9(10진수)
```

> 실제 비트 연산을 수행할 때의 최소 단위는 int(4byte = 32bit)이므로 10진수 3을 2진수로 변환하면 0이 30개, 1이 2개인 32비트 2진수로 변환됩니다.  다만 앞의 0들은 연산 결과에 영향을 미치지 않으므로 생략해 표현할 수 있습니다.

```Java
int a = 3;
int b = 0b00000000000000000000000000000011;
int c = 0b0011; 
```

- 비트 NOT 연산 과정
NOT 연산자를 이해하기 위해서는 음숫값과 양숫값을 알아야 합니다.
값의 첫 번째 비트는 부호 비트이며 0이면 양수, 1이면 음수 입니다.
여기서 양수의 경우 일반 2진법 수와 같지만 음수의 경우 +1을 해줍니다.

```
~ 00000011 <- 3(10진수)
----------
  11111100 <- -4(10진수)

// 양수는 `1`을 카운트 하지만, 음수는 `0`을 카운트하고 +1 해줍니다.
```

### 시프트 연산자

시프트(shift) 연산자는 비트의 위치를 좌우로 이동하는 연산으로, 산술 시프트(<<, >>)와 논리(>>>) 시프트가 있습니다.

- 산술 시프트
숫자의 부호 비트는 유지하되 나머지 비트를 좌(<<), 우(>>)로 이동하는 연산자입니다.
<< 연산을 하게 되면 비트가 왼쪽으로 이동하기 때문에 1bit 당 X 2의 효과가 있고, 반대로 >> 연산을 하게 되면 비트가 오른쪽으로 이동하기 때문에 1bit 당 / 2의 효과가 있습니다.
이동하며 생긴 공백은 좌우 동일하게 `0`으로 채워집니다. 

> >> 연산에서는 삭제되는 비트 때문에 값을 2로 나눈 결과와 다르게 나타날 수 있습니다.
이유는 최하위 비트값이 시프트 과정에서 삭제되기 때문입니다. (예를 들어 0b0011 >> 1 = 1.5가 아닌 1)

| 연산자 	| 부호       	| 특성                                    	| 예                       	|
|--------	|------------	|-----------------------------------------	|--------------------------	|
| <<     	| 양수, 음수 	| 1bit 시프트당 * 2, 부호 유지            	| 3 << 1 = 6, -3 << 1 = -6 	|
| >>     	| 양수       	| 1bit 시프트당 / 2, 부호 유지, 소수 버림 	| 5 >> 2 = 1               	|
|        	| 음수       	| 1bit 시프트당 / 2, 부호 유지, 소수 올림 	| -5 >> 2 = -2             	|


- 논리 시프트의 경우 부호 비트를 포함하여 이동하기 때문에 음수일 때 사용하게 되면 값이 양수가 됩니다.  그리고 보통 각 비트 위치에서의 값만이 의미를 있을 때 주로 사용하는 연산이므로 숫자의 크기나 부호는 의미가 없습니다.

### 비교 연산자

비교 연산자는 크기 비교와 등가 비교로 나눠지며, 연산 결과는 불리언(boolean)인 참(true)과 거짓(false)중 하나를 나타냅니다.

비교 연산자에서 중요한 것은 `등가 비교(==, !=)할 때 비교 대상은 스택(stack) 메모리의 값을 비교합니다.`
따라서 기본 자료형의 등가 비교 대상은 실제 데이터값이 되고, 참조 자료형의 등가 비교 대상은 데이터값이 위치한 번짓값이 됩니다.

### 논리 연산자

| value 1 	| value 2 	| AND(&&) 	| OR(\|\|) 	| XOR(^) 	|
|---------	|---------	|---------	|----------	|--------	|
| false   	| false   	| false   	| false    	| false  	|
| false   	| true    	| false   	| true     	| true   	|
| true    	| false   	| false   	| true     	| true   	|
| true    	| true    	| true    	| true     	| false  	|


| value 	| NOT(!) 	|
|-------	|--------	|
| false 	| true   	|
| true  	| false  	|


- 쇼트 서킷(short circuit)
연산을 수행하는 과정에서 결과가 이미 확정됐을 때 나머지 연산 과정을 생략하는 것을 말합니다.
예를 들어 비트 OR(||) 연산자의 경우 왼쪽 값이 true일 경우 우측값은 읽지 않고 생략하게 됩니다.

> 불필요한 연산은 생략하기 때문에 좋다고 생각할 순 있지만, 증감 연산자가 우측에 있을 경우 아예 실행을 생략하므로 쇼트 서킷을 의도적으로 적용하지 말아야 할 경우도 있습니다.

> 논리 XOR 연산자의 경우 항상 양쪽 값을 모두 확인해야 되기 때문에 쇼트 서킷을 적용할 수 없습니다.

### 대입 연산자

| 일반 표현   	| 축약 표현 	|
|-------------	|-----------	|
| a = a + b   	| a += b    	|
| a = a - b   	| a -= b    	|
| a = a * b   	| a *= b    	|
| a = a / b   	| a /= b    	|
| a = a & b   	| a &= b    	|
| a = a \| b  	| a \|= b   	|
| a = a >> b  	| a >>= b   	|
| a = a << b  	| a <<= b   	|
| a = a >>> b 	| a >>>= b  	|

### 삼항 연산자
자바 연산자 중 유일하게 3개의 피연산자가 있는 연산자입니다.
`(참(true) 또는 거짓(false)) ? 참(true)일 때 연산 결과 : 거짓(false)일 때 연산 결과`

```java
int a = (true) ? 1 : 2;           // 1
int b = (a % 2 == 0) ? 10 : 20;   // 20
```

- 삼항 연산자와 if 선택 제어문 사이의 변환
```java
int a = 3;
int b;

if (a > 5) {
  b = 10;
} else {
  b = 20;
}

System.out.println(b);    // 20
```
